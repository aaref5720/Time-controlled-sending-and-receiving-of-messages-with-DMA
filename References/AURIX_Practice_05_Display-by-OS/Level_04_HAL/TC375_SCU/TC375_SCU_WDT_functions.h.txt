/**********************************************************************************************************************
 * \file TC375_SCU_WDT_functions.h
 * \copyright Copyright (C) Harald Zweck 2025
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Harald Zweck.
 * If and as long as no such terms of use are agreed, use of this file is subject to following:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*--------------------------------------------------Documentation----------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * This file contains functionalities to control the watch-dogs of AURIX.
 * Watch-dogs must be correctly operated to change the core registers of AURIX, e.g. the registers which control the
 * PLLs. Incorrect operation triggers AURIX traps.
 * The functions are implemented as inline functions. The compiler does not create function calls, based on the code.
 * The compiler inserts directly assembler code into the code image of the application.
 *
 */

/*
 * status: V01.1 2025-09-06
 */

/*********************************************************************************************************************/
/*-----------------------------------------------------Defines-------------------------------------------------------*/
/*********************************************************************************************************************/

#ifndef TC375_SCU_WDT_FUNCTIONS_H_
#define TC375_SCU_WDT_FUNCTIONS_H_

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include <Level_04_HAL/HAL_Libraries/HAL_Return_Types.h>

#include <Level_Libraries/iLLD/TC37A/Tricore/Cpu/Std/Platform_Types.h>
#include <Level_Libraries/Infra/Platform/Tricore/Compilers/CompilerTasking.h>
#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxScu_reg.h>

/*********************************************************************************************************************/
/*-----------------------------------------------------Externals-----------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


/*
 * function:    Func_read_EICON0_password
 * returns:     uint16
 * parameters:  void
 * description: The function reads the password from the EICON0 register and adapts the bits 7..2.
 */

IFX_INLINE uint16 Func_read_EICON0_password(void)
{
    uint16 password;

    /* Read Password from EICON0 register field EPW
     * Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    password = (uint16)SCU_EICON0.U;
    password = password >> 2;
    password ^= 0x03F;          // this operation re-inverts bits [7..2]

    return password;
}


/*
 * function:    Func_read_SEICON0_password
 * returns:     uint16
 * parameters:  void
 * description: The function reads the password from the SEICON0 register and adapts the bits 7..2.
 */

IFX_INLINE uint16 Func_read_SEICON0_password(void)
{
    uint16 password;

    /* Read Password from SEICON0 register field EPW
     * Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    password = (uint16)SCU_SEICON0.U;
    password = password >> 2;
    password ^= 0x03F;          // this operation re-inverts bits [7..2]

    return password;
}


/*
 * function:    Func_clear_Global_ENDINIT
 * returns:     void
 * parameters:  void
 * description: The function clears (reset to 0) the ENDINIT flag.
 *              Resetting the ENDINIT flag allows access to ENDINIT protected registers.
 *              For this purpose the function reads the password from the EICON0 register and adapts the bits 7..2.
 */
IFX_INLINE void Func_clear_Global_ENDINIT(void)
{
    uint32 EICON0_register;

    /* Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    EICON0_register = (uint32)SCU_EICON0.U;
    EICON0_register ^= 0x000000FC;              // re-invert inverted password bits [7..2].

    if ((EICON0_register & 0x00000002) != 0)    // the ENDINIT flag must be set to 0
    {
        EICON0_register = EICON0_register & 0xFFFFFFFD;

        SCU_EICON0.U = EICON0_register;           // resetting ENDININT flag gives access to protected registers.
    }

    while ((SCU_EICON0.U & 0x00000002) != 0)
    {};

    return;
}


/*
 * function:    Func_set_Global_ENDINIT
 * returns:     void
 * parameters:  void
 * description: The function set (set to 1) the ENDINIT flag.
 *              Setting the ENDINIT flag disables the access to ENDINIT protected registers. Trying to access protected registers
 *              results in a bus trap.
 *              For this purpose the function reads the password from the EICON0 register and adapts the bits 7..2.
 */
IFX_INLINE void Func_set_Global_ENDINIT(void)
{
    uint32 EICON0_register;

    /* Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    EICON0_register = (uint32)SCU_EICON0.U;
    EICON0_register ^= 0x000000FC;              // re-invert inverted password bits [7..2].

    if ((EICON0_register & 0x00000002) == 0)    // the ENDINIT flag should must set to 1
    {
        EICON0_register = EICON0_register | 0x00000002;

        SCU_EICON0.U = EICON0_register;           // setting ENDININT flag disables the access to protected registers.
    }

    while ((SCU_EICON0.U & 0x00000002) == 0)
    {};

    return;
}


/*
 * function:    Func_clear_Global_SafeENDINIT
 * returns:     void
 * parameters:  void
 * description: The function clears (reset to 0) the ENDINIT flag.
 *              Resetting the ENDINIT flag allows access to ENDINIT protected registers.
 *              For this purpose the function reads the password from the SEICON0 register and adapts the bits 7..2.
 */
IFX_INLINE void Func_clear_Global_SafeENDINIT(void)
{
    uint32 SEICON0_register;

    /* Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    SEICON0_register = (uint32)SCU_SEICON0.U;
    SEICON0_register ^= 0x000000FC;              // re-invert inverted password bits [7..2].

    if ((SEICON0_register & 0x00000002) != 0)    // the ENDINIT flag must be set to 0
    {
        SEICON0_register = SEICON0_register & 0xFFFFFFFD;

        SCU_SEICON0.U = SEICON0_register;           // resetting ENDININT flag gives access to protected registers.
    }

    while ((SCU_SEICON0.U & 0x00000002) != 0)
    {};

    return;
}


/*
 * function:    Func_set_Global_SafeENDINIT
 * returns:     void
 * parameters:  void
 * description: The function set (set to 1) the ENDINIT flag.
 *              Setting the ENDINIT flag disables the access to ENDINIT protected registers. Trying to access protected registers
 *              results in a bus trap.
 *              For this purpose the function reads the password from the SEICON0 register and adapts the bits 7..2.
 */
IFX_INLINE void Func_set_Global_SafeENDINIT(void)
{
    uint32 SEICON0_register;

    /* Attention: According to the Open Market V2.0.0 manual "Infineon_AURIX_TC3xx_Part1-UserManual" a read operation
     * does not provide the actually valid password, the bits [7..2] are inverted.
     * Note: The default password is: 0x003C;
     */

    SEICON0_register = (uint32)SCU_SEICON0.U;
    SEICON0_register ^= 0x000000FC;              // re-invert inverted password bits [7..2].

    if ((SEICON0_register & 0x00000002) == 0)    // the ENDINIT flag should must set to 1
    {
        SEICON0_register = SEICON0_register | 0x00000002;

        SCU_SEICON0.U = SEICON0_register;           // setting ENDININT flag disables the access to protected registers.
    }

    while ((SCU_SEICON0.U & 0x00000002) == 0)
    {};

    return;
}


#endif /* TC375_SCU_WDT_FUNCTIONS_H_ */

