    /**********************************************************************************************************************
 * \file TC375_MCAN_MsgRAM.c
 * \copyright Copyright (C) Harald Zweck 2025
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Harald Zweck.
 * If and as long as no such terms of use are agreed, use of this file is subject to following:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*--------------------------------------------------Documentation----------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * In this file the layout of the data sections of the MCAN Message Ram is defined.
 *
 *
 * the template code uses CAN Module 0.
 * within Module 0 two CAN Nodes are used: CAN Node 0 (CAN0) and CAN Node 1 (CAN1).
 */


/*
 * status: V01.1 2025-12-13
 */

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * IfxPort_reg.h includes the definitions of the Infineon iLLDs for access to ports, peripherals, etc.
 */

#include <Level_04_HAL/HAL_Libraries/HAL_Return_Types.h>
#include <Level_Libraries/iLLD/TC37A/Tricore/Cpu/Std/Platform_Types.h>

#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxCan_reg.h>

#include <Level_04_HAL/TC375_CAN/TC375_MCAN.h>


/*********************************************************************************************************************/
/*-----------------------------------------------------Defines-------------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Externals-----------------------------------------------------*/
/*********************************************************************************************************************/



/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * the definition of the Message RAM of CAN Module 0.
 * the address pointer MCAN0_RAM points to the RAM of CAN Module 0.
 * within CAN Module 0 two CAN Nodes are used: CAN Node 0 (CAN0) and CAN Node 1 (CAN1).
 * the CAN Nodes share the Message RAM of CAN Module 0.
 */
CAN_Module0_MsgRAM_struct *ptr_MCAN0_MsgRAM = (CAN_Module0_MsgRAM_struct *)MCAN0_RAM;

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*
 * function:    Func_MsgRAM_init
 * returns:     HAL_Return_Type error report
 * parameters:  uint8 msg_nr
 * description: The function initializes one Tx buffer
 */

HAL_Return_Type Func_MsgRAM_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    /*
     * initialization of the MCAN (Module) registers, which configure the Message RAM of CAN Module 0
     */

    /*
     * configuration for CAN Module 0 Node 0 (CAN0_N0)
     */

    /*
     * setting the Global Filter Configuration
     * register GFC
     */

    /*
     * Reject Remote Frames Extended
     */
    CAN0_N0_GFC.B.RRFE = 0x1;

    /*
     * Reject Remote Frames Standard
     */
    CAN0_N0_GFC.B.RRFS = 0x1;

    /*
     * Reject non-matching Frames Standard
     */
    CAN0_N0_GFC.B.ANFS = 0x3;

    /*
     * Reject non-matching Frames Extended
     */
    CAN0_N0_GFC.B.ANFE = 0x3;


    /*
     * *** Rx STandard Filters
     * set Rx Standard Filters start address and Standard Filter count register
     */

    CAN0_N0_SIDFC.B.LSS = Count_Std_Filters;

    CAN0_N0_SIDFC.B.FLSSA = (ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter - ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * set Rx Extended Filters start address and Extended Filter count
     * no Extended Filters
     */
    CAN0_N0_XIDFC.B.LSE = 0x0;

    CAN0_N0_XIDFC.B.FLESA = 0x0;

    /*
     * *** Rx Buffers
     * configuration of the start address of the Rx buffers
     */
    CAN0_RXBC0.B.RBSA = ((void *)ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers - (void *)ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * configuration of Rx buffer data size
     */
    CAN0_RXESC0.B.RBDS = Size_data_Buffer_indexed;

    /*
     * *** Tx Buffers
     * configuration of the count of the Tx buffers
     */
    CAN0_TXBC0.B.NDTB = Count_Tx_Buffers;

    /*
     * configuration of the start address of the Tx buffers
     */
    CAN0_TXBC0.B.TBSA = ((void *)ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers - (void *)ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * configuration of Tx buffer data size
     * the size of the Tx buffers is the same as the Rx buffers
     */
    CAN0_TXESC0.B.TBDS = Size_data_Buffer_indexed;

    /*
     * configuration and de-activation of Tx Queues / FIFOs
     */
    CAN0_TXBC0.B.TFQM = 0x0;
    CAN0_TXBC0.B.TFQS = 0x0;


    /*
     * configuration for CAN Module 0 Node 1 (CAN0_N1)
     */

    /*
     * setting the Global Filter Configuration
     * register GFC
     */

    /*
     * Reject Remote Frames Extended
     */
    CAN0_N1_GFC.B.RRFE = 0x1;

    /*
     * Reject Remote Frames Standard
     */
    CAN0_N1_GFC.B.RRFS = 0x1;

    /*
     * Reject non-matching Frames Standard
     */
    CAN0_N1_GFC.B.ANFS = 0x3;

    /*
     * Reject non-matching Frames Extended
     */
    CAN0_N1_GFC.B.ANFE = 0x3;


    /*
     * *** Rx STandard Filters
     * set Rx Standard Filters start address and Standard Filter count register
     */

    CAN0_N1_SIDFC.B.LSS = Count_Std_Filters;

    CAN0_N1_SIDFC.B.FLSSA = (ptr_MCAN0_MsgRAM->Region_CAN1_Standard_Filter - ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * set Rx Extended Filters start address and Extended Filter count
     * no Extended Filters
     */
    CAN0_N1_XIDFC.B.LSE = 0x0;

    CAN0_N1_XIDFC.B.FLESA = 0x0;

    /*
     * *** Rx Buffers
     * configuration of the start address of the Rx buffers
     */
    CAN0_RXBC1.B.RBSA = ((void *)ptr_MCAN0_MsgRAM->Region_CAN1_Rx_Buffers - (void *)ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * configuration of Rx buffer data size
     */
    CAN0_RXESC1.B.RBDS = Size_data_Buffer_indexed;

    /*
     * *** Tx Buffers
     * configuration of the count of the Tx buffers
     */
    CAN0_TXBC1.B.NDTB = Count_Tx_Buffers;

    /*
     * configuration of the start address of the Tx buffers
     */
    CAN0_TXBC1.B.TBSA = ((void *)ptr_MCAN0_MsgRAM->Region_CAN1_Tx_Buffers - (void *)ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter);

    /*
     * configuration of Tx buffer data size
     * the size of the Tx buffers is the same as the Rx buffers
     */
    CAN0_TXESC1.B.TBDS = Size_data_Buffer_indexed;

    /*
     * configuration and de-activation of Tx Queues / FIFOs
     */
    CAN0_TXBC1.B.TFQM = 0x0;
    CAN0_TXBC1.B.TFQS = 0x0;



    /*
     * the correct setting of the register is not checked in the example
     */

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_CAN0_Tx_buffer0_init
 * returns:     HAL_Return_Type error report
 * parameters:  uint8 msg_nr
 * description: The function initializes only the first Tx buffer
 */
HAL_Return_Type Func_CAN0_Tx_buffer0_init (uint8 msg_nr)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T0.ESI = 0x0;         // ESI bit depends only on error passive ﬂag
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T0.XTD = 0x0;         // 11 bit standard identifier (see ID)
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T0.RTR = 0x0;         // no Remote Transmission Request
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T0.ID  = 0x00400000;  // only bits 28..18 are used; ID is 0x10; ID is sent out on the CAN network
                                                                                // binary 000 0.0000.0100.00 00.0000.0000.0000.0000;
                                                                                // hex 0x00400000
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T1.BRS = 0x0;         // no Bit Rate Switch
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T1.DLC = 8;           // 8 data bytes per frame
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T1.EFC = 0x0;         // don't store transmit events; we don't use it in the practice
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T1.FDF = 0x0;         // Frame transmitted in Classic CAN format
    ptr_MCAN0_MsgRAM->Region_CAN0_Tx_Buffers[0].Tx_Buffer_T1.MM  = msg_nr;      // this is message number 0; we don't use it in the practice

    /*
     * the correct setting of the buffer is not checked in the example
     */

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_CAN0_Rx_buffer0_init
 * returns:     HAL_Return_Type error report
 * parameters:  uint8 msg_nr
 * description: The function initializes only the first Rx buffer
 */
HAL_Return_Type Func_CAN0_Rx_buffer0_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R0.ESI = 0x0;         // ESI bit depends only on error passive ﬂag
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R0.XTD = 0x0;         // 11 bit standard identifier (see ID)
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R0.RTR = 0x0;         // no Remote Transmission Request
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R0.ID  = 0x00800000;  // only bits 28..18 are used; ID is 0x20; ID is sent out on the CAN network
                                                                                // binary 000 0.0000.1000.00 00.0000.0000.0000.0000
                                                                                // hex 0x00800000
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.BRS = 0x0;         // no Bit Rate Switch
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.DLC = 8;           // 8 data bytes per frame
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.FDF = 0x0;         // Frame transferred in Classic CAN format
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.FIDX= 0x0;         // outputs after a reception the matching filter number
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.ANMF= 0x0;         // only matching frames are received
    ptr_MCAN0_MsgRAM->Region_CAN0_Rx_Buffers[0].Rx_Buffer_R1.RXTS= 0x0;         // time stamp, not used

    /*
     * the correct setting of the buffer is not checked in the example
     */

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_CAN0_Rx_Filter0_init
 * returns:     HAL_Return_Type error report
 * parameters:  uint8 msg_nr
 * description: The function initializes only the first Rx Filter element
 */
HAL_Return_Type Func_CAN0_Rx_Filter0_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter[0].SFEC   = 0x7;          // store message in Rx buffer, defined by SFID 2
    ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter[0].SFID1  = 0x20;         // inbound message are filtered for match with ID 0x20
    ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter[0].SFT    = 0x0;          // unused
    ptr_MCAN0_MsgRAM->Region_CAN0_Standard_Filter[0].SFID2  = 0x0;          // in case of match put the received frame into address (RXBC0.RBSA + 0x0)

    /*
     * the correct setting of the buffer is not checked in the example
     */

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}

