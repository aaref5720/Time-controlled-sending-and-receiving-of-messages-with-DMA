/**********************************************************************************************************************
 * \file TC375_MCAN_functions.c
 * \copyright Copyright (C) Harald Zweck 2025
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Harald Zweck.
 * If and as long as no such terms of use are agreed, use of this file is subject to following:
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*--------------------------------------------------Documentation----------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * The code in this file shall provide the following functionalities:
 *
 * switching on the clocks for the MCAN module and for the CAN communication.
 *
 * set MCAN init to on
 * set MCAN init to off
 *
 * set MCAN control
 *
 * set the Nominal Baud rate
 * set the Data Baud rate
 *
 * initialize the IO ports for the CAN0 and CAN1 interfaces
 *
 */

/*
 * status: V01.1 2025-12-13
 */

/*********************************************************************************************************************/
/*-----------------------------------------------------Defines-------------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * IfxPort_reg.h includes the definitions of the Infineon iLLDs for access to ports, peripherals, etc.
 */

#include <Level_04_HAL/HAL_Libraries/HAL_Return_Types.h>
#include <Level_Libraries/iLLD/TC37A/Tricore/Cpu/Std/Platform_Types.h>

#include <Level_Libraries/iLLD/TC37A/Tricore/CAN/Std/IfxCan.h>
#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxCan_reg.h>

#include <Level_04_HAL/TC375_CAN/TC375_MCAN.h>

#include <Level_04_HAL/TC375_SCU/TC375_SCU_WDT_functions.h>


/*********************************************************************************************************************/
/*-----------------------------------------------------Externals-----------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/



/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*
 * function:    Func_set_MCAN0_N0_init_on
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function enables to access to the CAN Module 0 / CAN Node 0 configuration bits
 */
HAL_Return_Type Func_set_MCAN0_N0_init_on (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
    volatile uint32 tmp_uint32;

    /*
     * set the following control bits:
     *
     * CAN0_CCCR0.B.CCCE = 1;
     * CAN0_CCCR0.B.CI = 1;
     *
     */
    tmp_uint32 = CAN0_CCCR0.U;
    tmp_uint32 = tmp_uint32 | 0x00000003;
    CAN0_CCCR0.U = tmp_uint32;

    /*
     * insert delay read
     */
    tmp_uint32 = CAN0_CCCR0.U;

    if((tmp_uint32 & 0x00000003) == 0x00000003)
    {
        tmp_HAL = HAL_E_OK;
    }
    else
    {
        tmp_HAL = HAL_E_NOT_OK;
    }
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_set_MCAN0_N0_init_off
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function disables to access to the CAN Module 0 / CAN Node 0 configuration bits
 */
HAL_Return_Type Func_set_MCAN0_N0_init_off (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
    volatile uint32 tmp_uint32;

    /*
     * set the following control bits:
     *
     * CAN0_CCCR0.B.CCCE = 0;
     * CAN0_CCCR0.B.CI = 0;
     *
     */
    tmp_uint32 = CAN0_CCCR0.U;
    tmp_uint32 = tmp_uint32 & 0xFFFFFFFC;
    CAN0_CCCR0.U = tmp_uint32;

    /*
     * insert delay read
     */
    tmp_uint32 = CAN0_CCCR0.U;

    if((tmp_uint32 & 0x00000003) == 0x0)
    {
        tmp_HAL = HAL_E_OK;
    }
    else
    {
        tmp_HAL = HAL_E_NOT_OK;
    };
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_switch_MCAN0_N0_clock_on
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function switches both clocks for CAN Node 0 on
 */
HAL_Return_Type Func_switch_MCAN0_N0_clock_on (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
    volatile uint32 tmp_uint32;

    tmp_uint32 = CAN0_MCR.U;

    /*
     * set the following control bits:
     *
     * CAN0_MCR.B.CCCE = 1;
     * CAN0_MCR.B.CI = 1;
     * CAN0_MCR.B.CLKSEL0 = 0x3; // set both clocks of Node0 to on
     */
    tmp_uint32 = tmp_uint32 | (0xC0000000 | 0x00000003);
    CAN0_MCR.U = tmp_uint32;

    /*
     * clear the following control bits:
     *
     CAN0_MCR.B.CCCE = 0;
     CAN0_MCR.B.CI = 0;
     */
    tmp_uint32 = CAN0_MCR.U & (~0xC0000000);
    CAN0_MCR.U = tmp_uint32;

    /*
     * insert delay
     */
    tmp_uint32 = CAN0_MCR.U;

    if ( (  (tmp_uint32 & 0xC0000000) == 0x0) && ( (tmp_uint32 & 0x00000003) == 0x3) )
    {
        tmp_HAL = HAL_E_OK;
    }
    else
    {
        tmp_HAL = HAL_E_NOT_OK;
    }

    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_run_MCAN0_RAM_init
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function runs an initialization sequence for CAN Module 0 RAM
 */
HAL_Return_Type Func_run_MCAN0_RAM_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
    volatile uint32 tmp_uint32;
    volatile boolean init_busy = TRUE;

    /*
     * set the following control bits:
     *
     * CAN0_MCR.B.CCCE = 1;
     * CAN0_MCR.B.CI = 1;
     */

    tmp_uint32 = CAN0_MCR.U | 0xC0000000;
    CAN0_MCR.U = tmp_uint32;

    do
    {
        if (CAN0_MCR.B.RBUSY == 0x0)
        {
            init_busy = FALSE;
        }
        else
        {
            init_busy = TRUE;
        }
    } while (init_busy == TRUE);

    CAN0_MCR.B.RINIT = 0x0;
    CAN0_MCR.B.RINIT = 0x1;

    tmp_uint32 = CAN0_MCR.U;

    do
    {
        if (CAN0_MCR.B.RBUSY == 0x0)
        {
            init_busy = FALSE;
        }
        else
        {
            init_busy = TRUE;
        }
    } while (init_busy == TRUE);

    CAN0_MCR.B.RINIT = 0x0;

    /*
     * clear the following control bits:
     *
     CAN0_MCR.B.CCCE = 0;
     CAN0_MCR.B.CI = 0;
     */
    tmp_uint32 = CAN0_MCR.U & (~0xC0000000);
    CAN0_MCR.U = tmp_uint32;

    tmp_HAL = HAL_E_OK;

    return tmp_HAL;
}



/*********************************************************************************************************************/
/*
 * function:    Func_set_MCAN0_N0_control
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function sets the CAN0 controls and starts the initialization procedure
 */
HAL_Return_Type Func_set_MCAN0_N0_control (void)
{
    uint32 tmp_uint32;
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    /*
     * enable initialization
     */

    CAN0_CCCR0.B.INIT = 0x1;
    /*
     * insert delay read
     */
    tmp_uint32 = CAN0_CCCR0.U;
    CAN0_CCCR0.B.CCE  = 0x1;

    /*
     * the CAN Node 0 will be set to CAN Standard mode (no FD support)
     */
    CAN0_CCCR0.B.NISO = 0x0;
    CAN0_CCCR0.B.TXP  = 0x0;
    CAN0_CCCR0.B.EFBI = 0x0;
    CAN0_CCCR0.B.PXHD = 0x0;
    CAN0_CCCR0.B.BRSE = 0x0; // bit rate switching disabled
    CAN0_CCCR0.B.FDOE = 0x0; // FD operation disabled
    CAN0_CCCR0.B.TEST = 0x0;
    CAN0_CCCR0.B.DAR  = 0x1; // automatic retransmission disabled
    CAN0_CCCR0.B.MON  = 0x0;
    CAN0_CCCR0.B.CSR  = 0x0; // no clock stop request
    CAN0_CCCR0.B.ASM  = 0x0;

    CAN0_CCCR0.B.INIT = 0x0;

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_set_MCAN0_N0_Nominal_Baudrate
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function sets the Nominal Baud rate, which is used for the CAN header etc.
 */
HAL_Return_Type Func_set_MCAN0_N0_Nominal_Baudrate (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    Func_set_MCAN0_N0_init_on();

    /*
     * set time quantum values for Nominal Baud rate
     * communication input clock is 80 Mhz, is reduced to 20 Mhz; divisor has to be 4 -> bit field NBRP -> 3
     * Phase Segment 1 and Prop Segment are accumulated to one value; NTSEG1 bitfield -> set to 8 + 21 -> 29;
     * Phase Segment 2 is calculated to 9; is set to 8
     * Sync Jump Width is calculated to 9; is set to 8
     *
     */
    CAN0_NBTP0.B.NBRP   = 0x3;
    CAN0_NBTP0.B.NTSEG1 = 29;
    CAN0_NBTP0.B.NTSEG2 = 8;
    CAN0_NBTP0.B.NSJW   = 8;

    Func_set_MCAN0_N0_init_off();

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_set_MCAN0_N0_Data_Baudrate
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function sets the Data Baud rate, which is used for the CAN data.
 */
HAL_Return_Type Func_set_MCAN0_N0_Data_Baudrate (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    Func_set_MCAN0_N0_init_on();

    /*
     * set time quantum values for Data Baud rate
     * communication input clock is 80 Mhz, is reduced to 20 Mhz; divisor has to be 4 -> bit field DBRP -> 3
     * Phase Segment 1 and Prop Segment are accumulated to one value; DTSEG1 bitfield -> set to 8 + 21 -> 29;
     * Phase Segment 2 is calculated to 9; is set to 8
     * Sync Jump Width is calculated to 9; is set to 8
     * Transmitter Delay Compensation is disabled
     *
     */
    CAN0_DBTP0.B.DBRP   = 0x3;
    CAN0_DBTP0.B.DTSEG1 = 29;
    CAN0_DBTP0.B.DTSEG2 = 8;
    CAN0_DBTP0.B.DSJW   = 8;
    CAN0_DBTP0.B.TDC    = 0x0;

    Func_set_MCAN0_N0_init_off();

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_MCAN0_N0_Port_connection_init
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function initializes the connection of MCAN0 module CAN N0 of  to IO ports
 */
HAL_Return_Type Func_MCAN0_N0_Port_connection_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    /*
     * MCAN Module 0 CAN Channel 0 is connected to:
     * TxD to P20.8
     * RxDB to P20.7
     *
     * Note: to enable the transceiver, the IO Port P20.6 must be driven to low.
     */
    CAN0_NPCR0.B.RXSEL = 0x1;

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


/*********************************************************************************************************************/
/*
 * function:    Func_MCAN0_N1_Port_connection_init
 * returns:     HAL_Return_Type error report
 * parameters:  void
 * description: The function initializes the connection of CAN1 of MCAN0 module to IO ports
 */
HAL_Return_Type Func_MCAN0_N1_Port_connection_init (void)
{
    HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;

    /*
     * MCAN Module 0 CAN Channel 1 is connected to:
     * TxD to P15.2
     * RxDB to P15.3
     *
     * Note: the transceiver is enabled by default, by HW
     */
    CAN0_NPCR1.B.RXSEL = 0x0;

    tmp_HAL = HAL_E_OK;
    return tmp_HAL;
}


