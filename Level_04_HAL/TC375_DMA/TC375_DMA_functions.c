/**********************************************************************************************************************
 * \file TC375_DMA_functions.c
 * \copyright Copyright (C) Harald Zweck 2025
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the
 *company in which ordinary course of business you are acting and (ii) Harald
 *Zweck. If and as long as no such terms of use are agreed, use of this file is
 *subject to following:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 *and to permit third-parties to whom the Software is furnished to do so, all
 *subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer, must
 *be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 *solely in the form of machine-executable object code generated by a source
 *language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 *ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------------Documentation----------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * The code in this file shall provide the following functionalities:
 *
 * 1) initialize the DMA module of TC375
 * 2)
 * 3)
 * 4)
 *
 * Note: You can use the predefined port addresses in the include file
 * IfxPort_reg.h
 */

/*
 * status: V01.0 2025-09-18
 */

/*********************************************************************************************************************/
/*-----------------------------------------------------Defines-------------------------------------------------------*/
/*********************************************************************************************************************/

#define CANRAM0_BASE     (0xF0200000u)
#define TX_TBSA_WORDS    (0x100u)                 /* TBSA you measured */
#define TX_TBSA_BYTES    (TX_TBSA_WORDS * 4u)
#define CAN_TXBUF0_DB0   (CANRAM0_BASE + TX_TBSA_BYTES + 0x08u)  /* = 0xF0200408 */



/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * IfxPort_reg.h includes the definitions of the Infineon iLLDs for access to
 * ports, peripherals, etc.
 */

#include <Level_04_HAL/HAL_Libraries/HAL_Return_Types.h>
#include <Level_04_HAL/TC375_SCU/TC375_SCU_WDT_functions.h>
#include <Level_Libraries/iLLD/TC37A/Tricore/Cpu/Std/Platform_Types.h>
#include <stddef.h>

#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxAsclin_reg.h>
#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxCan_reg.h>
#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxDma_reg.h>
#include <Level_Libraries/Infra/Sfr/TC37A/_Reg/IfxGpt12_reg.h>
#include <Level_04_HAL/TC375_CAN/TC375_MCAN.h>

/*********************************************************************************************************************/
/*-----------------------------------------------------Externals-----------------------------------------------------*/
/*********************************************************************************************************************/

extern uint16 DisplayOutputFIFO[];

extern volatile uint16 CAN_TxCounterValue;

/*********************************************************************************************************************/
/*-------------------------------------------------Global
 * variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function
 * Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Module_init
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function initializes the DMA module of TC375, which hosts
 * all DMA channels.
 */

HAL_Return_Type Func_DMA_Module_init(void) {
  HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
  uint32 tmp_uint32;

  Func_clear_Global_ENDINIT();

  /*
   * Initialization of the general DMA control register CLC to switch on clock
   *
   * field 0: DISR = 0: bit is cleared to 0 to enable the GPT12 module
   * field 1: DISS: bit is read only
   * field 2: reserved bit
   * field 3: EDIS = 1: bit is set to 1 to disable sleep mode
   * field 15..4: reserved
   * field 31..16: reserved
   *
   */

  DMA_CLC.B.DISR = 0x0;
  DMA_CLC.B.EDIS = 0x1;

  if (DMA_CLC.B.DISR == 0x0) {
    if (DMA_CLC.B.EDIS == 0x1) {
      tmp_HAL = HAL_E_OK;
    } else {
      tmp_HAL = HAL_E_NOT_OK;
    }
  } else {
    tmp_HAL = HAL_E_NOT_OK;
  }

  /*
   * do dummy read to finish register setup
   */

  tmp_uint32 = DMA_CLC.U;

  Func_set_Global_ENDINIT();

  return tmp_HAL;
}

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Ch0_init
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function initializes the DMA channel 0 of TC375.
 */

HAL_Return_Type Func_DMA_Ch0_init(void) {
  HAL_Return_Type tmp_HAL = HAL_E_NOT_OK;
  // uint32 tmp_uint32;

  /*
   * Initialization of the DMA channel 0, Channel Configuration Register CHCFGR
   *
   * field 13..0: TREL: 0x1: 1 transfer per transaction
   * field 15..14: reserved
   * field 18..16: BLKM: 0x2: 4 DMA Moves per transfer
   * field 19: RROAT: 0x1: a new DMA request is required after each DMA
   * transaction field 20: CHMOD: 0x1: continuous mode field 23..21: CHDW: 0x1:
   * 16 bit wide moves field 26..24: PATSEL: 0x0: no pattern detection field 27:
   * SWAP: 0x0: no swap field 28: PRSEL: 0x0: DMA HW request field 31..29:
   * reserved
   */

  DMA_CH0_CHCFGR.B.TREL = 0x1;
  DMA_CH0_CHCFGR.B.BLKM = 0x2;
  DMA_CH0_CHCFGR.B.RROAT = 0x1;
  DMA_CH0_CHCFGR.B.CHMODE = 0x1;
  DMA_CH0_CHCFGR.B.CHDW = 0x1;
  DMA_CH0_CHCFGR.B.PATSEL = 0x0;
  DMA_CH0_CHCFGR.B.SWAP = 0x0;
  DMA_CH0_CHCFGR.B.PRSEL = 0x0;

  /*
   * DMA_CH0_CHCFGR is not checked for correct setup
   */

  /*
   * Initialization of the DMA channel 0, Channel Address and Interrupt Control
   * Register ADICR
   *
   * field 2..0: SMF: 0x0, source address offset update is 1 x 16 bit for each
   * move field 3: INCS: 0x1, source addresses will be increased field 6..4:
   * DMF: 0x0, destination address offset update is 1 x 16 bit for each move
   * field 7: INCD: 0x1, destination address will be increased; this is for
   * documentation purpose only; the destination address will not change.
   * field 11..8: CBLS: 0x3, circular buffer source length is 4 entries a 16
   * bits field 15..12: CBLD: 0x0, destination circular buffer address is
   * unchanged; destination address stays the same. field 19..16: SHCT: 0x0,
   * move operation field 20: SCBE: 0x1, use source circular buffer field 21:
   * DCBE: 0x1, destination circular buffer; but the destination address stays
   * the same. field 22: STAMP: 0x0, no time stamp field 23: reserved field 24:
   * WRPSE: 0x0, no wrap source interrupt field 25: WRPDE: 0x0, no wrap
   * destination interrupt field 27..26: INTCT: 0x0, no interrupt on changing
   * TCOUNT field 31..28: IRDV: 0x0, no interrupt raise detect
   *
   */

  DMA_CH0_ADICR.B.SMF = 0x0;
  DMA_CH0_ADICR.B.INCS = 0x1;
  DMA_CH0_ADICR.B.DMF = 0x0;
  DMA_CH0_ADICR.B.INCD = 0x1;
  DMA_CH0_ADICR.B.CBLS = 0x3;
  DMA_CH0_ADICR.B.CBLD = 0x0;
  DMA_CH0_ADICR.B.SHCT = 0x0;
  DMA_CH0_ADICR.B.SCBE = 0x1;
  DMA_CH0_ADICR.B.DCBE = 0x1;
  DMA_CH0_ADICR.B.STAMP = 0x0;
  DMA_CH0_ADICR.B.WRPSE = 0x0;
  DMA_CH0_ADICR.B.WRPDE = 0x0;
  DMA_CH0_ADICR.B.INTCT = 0x0;
  DMA_CH0_ADICR.B.IRDV = 0x0;

  /*
   * DMA_CH0_ADICR is not checked for correct setup
   */

  /*
   * DMA_CH0_SADR,        // initialization of the DMA Channel 0 Source Address
   * register DMA_CH0_DADR,        // initialization of the DMA Channel 0
   * Destination Address register
   */

  DMA_CH0_SADR.U = (uint32)DisplayOutputFIFO;

  DMA_CH0_DADR.U = (uint32)&ASCLIN2_TXDATA;

  /*
   * DMA_CH0_SADR and DMA_CH0_DADR are not checked for correct setup
   */

  /*
   * DMA_TSR0,         // initialization of DMA Channel 0 TSR register
   */

  /*
   * field 4: ETRL: 0x0, disable TSR interrupt
   * field 18: CTL: 0x1, clear Transaction Lost flag
   * field 24: HLTCLR: 0x1, clear Halt Request and Halt Acknowledge
   *
   */

  DMA_TSR0.B.ETRL = 0x0;
  DMA_TSR0.B.CTL = 0x1;
  DMA_TSR0.B.HLTCLR = 0x1;

  /*
   * DMA_TSR0 is not checked for correct setup
   */

  /*
   * DMA_EER0,           // initialization of the error report enable register
   * of ME 0; no error reports. DMA_EER1,           // initialization of the
   * error report enable register of ME 1; no error reports.
   */

  DMA_EER0.U = 0x0;
  DMA_EER1.U = 0x0;

  /*
   * DMA_EER0 and DMA_EER1 are not checked for correct setup
   */

  tmp_HAL = HAL_E_OK;

  return tmp_HAL;
}

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Ch0_start
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function starts the DMA channel 0 of TC375.
 */

HAL_Return_Type Func_DMA_Ch0_start(void) {
  DMA_TSR0.B.ECH = 0x1;

  return HAL_E_OK;
}

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Ch0_stop
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function stops the DMA channel 0 of TC375
 */
HAL_Return_Type Func_DMA_Ch0_stop(void) {
  DMA_TSR0.B.DCH = 0x1;

  return HAL_E_OK;
}

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Ch1_init
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function initializes the DMA channel 1 of TC375 to copy
 * GPT12.T3 to CAN_TxCounterValue.
 */
/*
 * Initialize the DMA channel 1 of TC375 to copy GPT12.T3 to CAN_TxCounterValue.
 * Destination is CAN0 Message RAM Tx Buffer 0 Data Field (Offset 0x400 + 0x8).
 */
HAL_Return_Type Func_DMA_Ch1_init(void)
{
    /* 1 move per request, 16-bit transfer */
    DMA_CH1_CHCFGR.B.TREL = 0x1;
    DMA_CH1_CHCFGR.B.BLKM = 0x0;    // 1 move
    DMA_CH1_CHCFGR.B.RROAT = 0x1;
    DMA_CH1_CHCFGR.B.CHMODE = 0x1;
    DMA_CH1_CHCFGR.B.CHDW = 0x1;    // 16-bit move (TRM-correct)
    DMA_CH1_CHCFGR.B.PATSEL = 0x0;
    DMA_CH1_CHCFGR.B.SWAP = 0x0;
    DMA_CH1_CHCFGR.B.PRSEL = 0x0;

    /* no address increment */
    DMA_CH1_ADICR.B.SMF = 0x0;
    DMA_CH1_ADICR.B.INCS = 0x0;
    DMA_CH1_ADICR.B.DMF = 0x0;
    DMA_CH1_ADICR.B.INCD = 0x0;
    DMA_CH1_ADICR.B.CBLS = 0x0;
    DMA_CH1_ADICR.B.CBLD = 0x0;
    
    /* CRITICAL: enable software request triggering via SCH bit */
    DMA_CH1_ADICR.B.SHCT = 0x1;     // TRM-correct: allow software trigger
    
    DMA_CH1_ADICR.B.SCBE = 0x0;
    DMA_CH1_ADICR.B.DCBE = 0x0;
    DMA_CH1_ADICR.B.STAMP = 0x0;
    DMA_CH1_ADICR.B.WRPSE = 0x0;
    DMA_CH1_ADICR.B.WRPDE = 0x0;
    DMA_CH1_ADICR.B.INTCT = 0x1;
    DMA_CH1_ADICR.B.IRDV = 0x0;

    /* source = live Timer3 counter, destination = CAN TX DB0 */
    DMA_CH1_SADR.U = (uint32)&MODULE_GPT120.T3.U; // TRM-correct: live counter register
    DMA_CH1_DADR.U = CAN_TXBUF0_DB0;              // TRM-correct: 0xF0200408

    DMA_TSR1.B.ETRL = 0x0;
    DMA_TSR1.B.CTL = 0x1;
    DMA_TSR1.B.HLTCLR = 0x1;
    
    /* Enable channel 1 */
    DMA_TSR1.B.ECH = 0x1;   // TRM-correct: enable channel

    return HAL_E_OK;
}

/*********************************************************************************************************************/
/* helper: check whether DMA channel 1 is currently busy (TCOUNT != 0) */
HAL_Return_Type Func_DMA_Ch1_is_busy(boolean *busy) {
  if (busy == NULL)
    return HAL_E_NOT_OK;
  if (DMA_CH1_CHCSR.B.TCOUNT != 0) {
    *busy = TRUE;
  } else {
    *busy = FALSE;
  }
  return HAL_E_OK;
}

/*********************************************************************************************************************/
HAL_Return_Type Func_DMA_Ch1_start(void)
{
    /* Disable ch1 so config writes latch (TRM requirement) */
    DMA_TSR1.B.DCH = 1;

    /* Clear halt and transaction lost */
    DMA_TSR1.B.HLTCLR = 1;
    DMA_TSR1.B.CTL    = 1;

    /* Clear CH interrupt */
    MODULE_DMA.CH[1].CHCSR.B.CICH = 1;

    /* CRITICAL: Force correct destination EVERY TIME - prevents drift */
    MODULE_DMA.CH[1].DADR.U   = 0xF0200408u;   /* EXACT DB0 word address */
    MODULE_DMA.CH[1].SADR.U   = (uint32)&MODULE_GPT120.T3.U;
    MODULE_DMA.CH[1].CHCSR.B.TCOUNT = 1u;      /* one move (32-bit) */

    /* Program config for 32-bit transfer */
    MODULE_DMA.CH[1].CHCFGR.U = 0;
    MODULE_DMA.CH[1].CHCFGR.B.BLKM = 0;   /* single move */
    MODULE_DMA.CH[1].CHCFGR.B.CHDW = 2;   /* 32-bit (not 16-bit) */

    /* CRITICAL: Force no increment/decrement EVERY TIME */
    MODULE_DMA.CH[1].ADICR.U = 0;
    MODULE_DMA.CH[1].ADICR.B.SHCT = 1;    /* allow SCH to trigger */
    MODULE_DMA.CH[1].ADICR.B.INCS = 0;    /* no source increment */
    MODULE_DMA.CH[1].ADICR.B.INCD = 0;    /* no destination increment */
    MODULE_DMA.CH[1].ADICR.B.SMF  = 2;    /* 32-bit source move */
    MODULE_DMA.CH[1].ADICR.B.DMF  = 2;    /* 32-bit destination move */

    /* Force TCOUNT reset to prevent multi-transfer drift */
    MODULE_DMA.CH[1].CHCSR.B.TCOUNT = 1u;

    /* Enable ch1 */
    DMA_TSR1.B.ECH = 1;

    /* Software request */
    MODULE_DMA.CH[1].CHCSR.B.SCH = 1;

    return HAL_E_OK;
}

/*********************************************************************************************************************/
/*
 * function:    Func_DMA_Ch1_stop
 * returns:     HAL_Return_Type Error report
 * parameters:  void
 * description: The function stops the DMA channel 1 of TC375.
 */
HAL_Return_Type Func_DMA_Ch1_stop(void) {
  DMA_TSR1.B.DCH = 0x1;
  return HAL_E_OK;
}
