/**********************************************************************************************************************
 * \file Task_Display.c
 * \copyright Copyright (C) Harald Zweck 2025
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the
 *company in which ordinary course of business you are acting and (ii) Harald
 *Zweck. If and as long as no such terms of use are agreed, use of this file is
 *subject to following:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 *and to permit third-parties to whom the Software is furnished to do so, all
 *subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer, must
 *be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 *solely in the form of machine-executable object code generated by a source
 *language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 *ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------------Documentation----------------------------------------------------*/
/*********************************************************************************************************************/

/*
 * Job description
 *
 * The task - task_Display - shall control the 4 segment display on the THD
 * AdapterLite.
 *
 * It shall do 2 steps
 * 1) fill the buffer, which defines the content on the display, with characters
 * 2) send the buffer to the display
 * 3) fill the buffer with another content
 * 4) send the buffer to the display
 *    loop
 *
 */

/*
 * status: V01.1 2025-09-30
 */

/*********************************************************************************************************************/
/*-----------------------------------------------------Defines-------------------------------------------------------*/
/*********************************************************************************************************************/

#define Display_Content_Update_Speed 2000 // update every 2000 msec

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include <Level_02_Interfaces/Interface_Libraries/L02_Return_Types.h>
#include <Level_Libraries/iLLD/TC37A/Tricore/Cpu/Std/Platform_Types.h>

#include <Level_02_Interfaces/AdapterLite/IF_Display.h>
#include <Level_02_Interfaces/AdapterLite/IF_Switch1_Switch2.h>

#include <Level_04_HAL/TC375_CAN/TC375_CAN_functions.h>
#include <Level_04_HAL/TC375_DMA/TC375_DMA_functions.h>
#include <Level_04_HAL/TC375_GPT12/TC375_GPT12_functions.h>

#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"

/*********************************************************************************************************************/
/*-----------------------------------------------------Externals-----------------------------------------------------*/
/*********************************************************************************************************************/

// Reference to Level_02 Service functions

extern L02_Return_Type Func_Adapter_Display_init(void);
extern L02_Return_Type Func_Display_Update_Clock_init(void);
extern L02_Return_Type Func_Display_Update_Clock_start(void);

extern L02_Return_Type Func_SetDisplay(DisplayPrompt character, int position);
extern L02_Return_Type Func_Convert2Display(void);
// extern HAL_Return_Type Func_GPT12_T3_init_counter (void);
// extern HAL_Return_Type Func_GPT12_T3_get_value (uint16* value);
// extern HAL_Return_Type Func_GPT12_T3_set_value (uint16 value);
extern L02_Return_Type Func_Adapter_S1_init(void);
extern L02_Return_Type Func_Adapter_S2_init(void);
extern L02_Return_Type Func_Adapter_S1_status_read(boolean *status);
extern L02_Return_Type Func_Adapter_S2_status_read(boolean *status);
extern L02_Return_Type Func_Adapter_LED1_init(void);
extern L02_Return_Type Func_Adapter_LED1_on(void);
extern L02_Return_Type Func_Adapter_LED1_off(void);
extern volatile uint16 CAN_TxCounterValue;
extern uint32 txData[];

volatile uint8 g_send_divider = 0;
volatile uint8 g_send_tick = 0;

/* Timer and callback for non-blocking LED flash */
static TimerHandle_t xLed1Timer = NULL;
static void Led1TimerCallback(TimerHandle_t xTimer) {
  (void)xTimer;
  Func_Adapter_LED1_off();
}

/*********************************************************************************************************************/
/*-------------------------------------------------Global
 * variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function
 * Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*
 * The task task_Display operates the display on the Adapter
 * It puts characters into a buffer, which holds the content to be displayed
 * it sends the content of the buffer to the display
 *
 * error return messages are not checked
 */

void task_Display(void *arg) {
  L02_Return_Type tmp1;
  uint16 rxCnt = 0;
  static const DisplayPrompt map[10] = {DispPrompt_0noDot, DispPrompt_1noDot,
                                        DispPrompt_2noDot, DispPrompt_3noDot,
                                        DispPrompt_4noDot, DispPrompt_5noDot,
                                        DispPrompt_6noDot, DispPrompt_7noDot,
                                        DispPrompt_8noDot, DispPrompt_9noDot};

  tmp1 = Func_Adapter_Display_init();
  tmp1 = Func_Display_Update_Clock_init();
  /* Re-enable display clock and DMA CH0 so the display refresh works */
  tmp1 = Func_Display_Update_Clock_start();

  /* Initialize LED1 and ensure it starts in OFF state */
  Func_Adapter_LED1_init();
  Func_Adapter_LED1_off();

  /* Create software timer for non-blocking LED flash (0.5s) */
  xLed1Timer = xTimerCreate("LED1Timer", pdMS_TO_TICKS(500), pdFALSE, NULL,
                            Led1TimerCallback);

  /* If LED timer creation failed, set a flag to use blocking blink fallback */
  boolean use_blocking_led = FALSE;
  if (xLed1Timer == NULL) {
    use_blocking_led = TRUE;
    /* show a static 0 on display to indicate timer creation failed */
    tmp1 = Func_SetDisplay(map[0], 0);
    tmp1 = Func_SetDisplay(map[0], 1);
    tmp1 = Func_SetDisplay(map[0], 2);
    tmp1 = Func_SetDisplay(map[0], 3);
    tmp1 = Func_Convert2Display();
    /* ensure LED is visible */
    Func_Adapter_LED1_on();
  }

  tmp1 = Func_SetDisplay(map[0], 0);
  tmp1 = Func_SetDisplay(map[0], 1);
  tmp1 = Func_SetDisplay(map[0], 2);
  tmp1 = Func_SetDisplay(map[0], 3);
  tmp1 = Func_Convert2Display();

  /* Initialize Timer 3 as automatic hardware counter */
  Func_GPT12_T3_init_counter();
  Func_GPT12_T3_set_value(0);  /* Start counter from 0 */

  /* Initialize switches, CAN and DMA for Timer 3 -> CAN transfer */
  Func_Adapter_S1_init();
  Func_Adapter_S2_init();
  Func_CAN_init();
  Func_DMA_Module_init();
  Func_DMA_Ch1_init();

  {
    boolean s1 = FALSE, s2 = FALSE;
    boolean s1_prev = FALSE, s2_prev = FALSE;
    boolean t6_started = FALSE;

    while (TRUE) {
      uint32 notified = ulTaskNotifyTake(pdTRUE, pdMS_TO_TICKS(10));

      if (notified != 0u) {
        /* Try to receive CAN message - this updates debug counters */
        HAL_Return_Type canStatus = Func_CAN_receive_counter(&rxCnt);

        if (canStatus == HAL_E_OK) {
          /* Successful reception - show counter on display */
          tmp1 = Func_SetDisplay(map[(rxCnt / 1000) % 10], 0);
          tmp1 = Func_SetDisplay(map[(rxCnt / 100) % 10], 1);
          tmp1 = Func_SetDisplay(map[(rxCnt / 10) % 10], 2);
          tmp1 = Func_SetDisplay(map[(rxCnt / 1) % 10], 3);
          tmp1 = Func_Convert2Display();

          /* LED blinks ONLY on successful CAN RX (0.5 seconds on) */
          if (!use_blocking_led) {
            Func_Adapter_LED1_on();
            if (xLed1Timer != NULL) {
              xTimerStart(xLed1Timer, 0);
            }
          } else {
            Func_Adapter_LED1_on();
            vTaskDelay(pdMS_TO_TICKS(500));  /* 0.5 seconds on */
            Func_Adapter_LED1_off();
          }
        } else {
          /* No new RX data: show 9999 when CAN unplugged */
          tmp1 = Func_SetDisplay(map[9], 0);
          tmp1 = Func_SetDisplay(map[9], 1);
          tmp1 = Func_SetDisplay(map[9], 2);
          tmp1 = Func_SetDisplay(map[9], 3);
          tmp1 = Func_Convert2Display();
          /* NO LED blink when no data */
        }
      }

      Func_Adapter_S1_status_read(&s1);
      Func_Adapter_S2_status_read(&s2);

      if (s1 == TRUE && s1_prev == FALSE) {
        g_send_divider = 1u;
        g_send_tick = 0u;

        if (!t6_started) {
          Func_GPT12_T6_init();
          Func_GPT12_T6_set_period_1s();
          Func_GPT12_T6_enable_interrupts();
          Func_GPT12_T6_start();
          
          /* GPT12 init can disturb T2 -> restore display refresh */
          Func_Display_Update_Clock_init();
          Func_Display_Update_Clock_start();
          
          t6_started = TRUE;
        } else {
          Func_GPT12_T6_stop();
          Func_GPT12_T6_set_period_1s();
          Func_GPT12_T6_start();
          
          /* GPT12 init can disturb T2 -> restore display refresh */
          Func_Display_Update_Clock_init();
          Func_Display_Update_Clock_start();
        }
      } else if (s2 == TRUE && s2_prev == FALSE) {
        g_send_divider = 2u;
        g_send_tick = 0u;

        if (!t6_started) {
          Func_GPT12_T6_init();
          Func_GPT12_T6_set_period_1s();
          Func_GPT12_T6_enable_interrupts();
          Func_GPT12_T6_start();
          
          /* GPT12 init can disturb T2 -> restore display refresh */
          Func_Display_Update_Clock_init();
          Func_Display_Update_Clock_start();
          
          t6_started = TRUE;
        } else {
          Func_GPT12_T6_stop();
          Func_GPT12_T6_set_period_1s();
          Func_GPT12_T6_start();
          
          /* GPT12 init can disturb T2 -> restore display refresh */
          Func_Display_Update_Clock_init();
          Func_Display_Update_Clock_start();
        }
      }

      s1_prev = s1;
      s2_prev = s2;
    }
  }

  /*
   * The task shall never arrive at this point. If yes it will be deleted.
   */
  vTaskDelete(NULL);
}
